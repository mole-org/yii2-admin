{"version":3,"sources":["jquery.pjax.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.plugins.js","sourcesContent":["// jquery.pjax.js\n// copyright chris wanstrath\n// https://github.com/defunkt/jquery-pjax\n\n(function ($) {\n\n// When called on a container with a selector, fetches the href with\n// ajax into the container or with the data-pjax attribute on the link\n// itself.\n//\n// Tries to make sure the back button and ctrl+click work the way\n// you'd expect.\n//\n// Exported as $.fn.pjax\n//\n// Accepts a jQuery ajax options object that may include these\n// pjax specific options:\n//\n//\n// container - Where to stick the response body. Usually a String selector.\n//             $(container).html(xhr.responseBody)\n//             (default: current jquery context)\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// For convenience the second parameter can be either the container or\n// the options object.\n//\n// Returns the jQuery object\n\tfunction fnPjax(selector, container, options) {\n\t\tvar context = this\n\t\treturn this.on('click.pjax', selector, function (event) {\n\t\t\tvar opts = $.extend({}, optionsFor(container, options))\n\t\t\tif (!opts.container)\n\t\t\t\topts.container = $(this).attr('data-pjax') || context\n\t\t\thandleClick(event, opts)\n\t\t})\n\t}\n\n// Public: pjax on click handler\n//\n// Exported as $.pjax.click.\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// If the click event target has 'data-pjax=\"0\"' attribute, the event is ignored, and no pjax call is made.\n//\n// Examples\n//\n//   $(document).on('click', 'a', $.pjax.click)\n//   // is the same as\n//   $(document).pjax('a')\n//\n//  $(document).on('click', 'a', function(event) {\n//    var container = $(this).closest('[data-pjax-container]')\n//    $.pjax.click(event, container)\n//  })\n//\n// Returns nothing.\n\tfunction handleClick(event, container, options) {\n\t\toptions = optionsFor(container, options)\n\n\t\tvar link = event.currentTarget\n\n\t\t// Ignore links with data-pjax=\"0\"\n\t\tif ($(link).data('pjax') == 0)\n\t\t\treturn\n\n\t\tif (link.tagName.toUpperCase() !== 'A')\n\t\t\tthrow \"$.fn.pjax or $.pjax.click requires an anchor element\"\n\n\t\t// Middle click, cmd click, and ctrl click should open\n\t\t// links in a new tab as normal.\n\t\tif (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)\n\t\t\treturn\n\n\t\t// Ignore cross origin links\n\t\tif (location.protocol !== link.protocol || location.hostname !== link.hostname)\n\t\t\treturn\n\n\t\t// Ignore anchors on the same page\n\t\tif (link.hash && link.href.replace(link.hash, '') ===\n\t\t\tlocation.href.replace(location.hash, ''))\n\t\t\treturn\n\n\t\t// Ignore empty anchor \"foo.html#\"\n\t\tif (link.href === location.href + '#')\n\t\t\treturn\n\n\t\tvar defaults = {\n\t\t\turl: link.href,\n\t\t\tcontainer: $(link).attr('data-pjax'),\n\t\t\ttarget: link\n\t\t}\n\n\t\tvar opts = $.extend({}, defaults, options)\n\t\tvar clickEvent = $.Event('pjax:click')\n\t\t$(link).trigger(clickEvent, [opts])\n\n\t\tif (!clickEvent.isDefaultPrevented()) {\n\t\t\tpjax(opts)\n\t\t\tevent.preventDefault()\n\t\t\t$(link).trigger('pjax:clicked', [opts])\n\t\t}\n\t}\n\n// Public: pjax on form submit handler\n//\n// Exported as $.pjax.submit\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// Examples\n//\n//  $(document).on('submit', 'form', function(event) {\n//    var container = $(this).closest('[data-pjax-container]')\n//    $.pjax.submit(event, container)\n//  })\n//\n// Returns nothing.\n\tfunction handleSubmit(event, container, options) {\n\t\toptions = optionsFor(container, options)\n\n\t\tvar form = event.currentTarget\n\n\t\tif (form.tagName.toUpperCase() !== 'FORM')\n\t\t\tthrow \"$.pjax.submit requires a form element\"\n\n\t\tvar defaults = {\n\t\t\ttype: form.method.toUpperCase(),\n\t\t\turl: form.action,\n\t\t\tdata: $(form).serializeArray(),\n\t\t\tcontainer: $(form).attr('data-pjax'),\n\t\t\ttarget: form\n\t\t}\n\n\t\tpjax($.extend({}, defaults, options))\n\n\t\tevent.preventDefault()\n\t}\n\n// Loads a URL with ajax, puts the response body inside a container,\n// then pushState()'s the loaded URL.\n//\n// Works just like $.ajax in that it accepts a jQuery ajax\n// settings object (with keys like url, type, data, etc).\n//\n// Accepts these extra keys:\n//\n// container - Where to stick the response body.\n//             $(container).html(xhr.responseBody)\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// Use it just like $.ajax:\n//\n//   var xhr = $.pjax({ url: this.href, container: '#main' })\n//   console.log( xhr.readyState )\n//\n// Returns whatever $.ajax returns.\n\tfunction pjax(options) {\n\t\toptions = $.extend(true, {}, $.ajaxSettings, pjax.defaults, options)\n\n\t\tif ($.isFunction(options.url)) {\n\t\t\toptions.url = options.url()\n\t\t}\n\n\t\tvar target = options.target\n\n\t\tvar hash = parseURL(options.url).hash\n\n\t\tvar context = options.context = findContainerFor(options.container)\n\n\t\t// We want the browser to maintain two separate internal caches: one\n\t\t// for pjax'd partial page loads and one for normal page loads.\n\t\t// Without adding this secret parameter, some browsers will often\n\t\t// confuse the two.\n\t\tif (!options.data)\n\t\t\toptions.data = {}\n\n\t\t// serializeArray (used in handleSubmit) produces arrays of key/value pairs\n\t\tif ($.isArray(options.data))\n\t\t\toptions.data.push({ name: '_pjax', value: context.selector })\n\t\telse\n\t\t\toptions.data._pjax = context.selector\n\n\t\tfunction fire(type, args) {\n\t\t\tvar event = $.Event(type, { relatedTarget: target })\n\t\t\tcontext.trigger(event, args)\n\t\t\treturn !event.isDefaultPrevented()\n\t\t}\n\n\t\tvar timeoutTimer\n\n\t\toptions.beforeSend = function (xhr, settings) {\n\t\t\t// No timeout for non-GET requests\n\t\t\t// Its not safe to request the resource again with a fallback method.\n\t\t\tif (settings.type !== 'GET') {\n\t\t\t\tsettings.timeout = 0\n\t\t\t}\n\n\t\t\txhr.setRequestHeader('X-PJAX', 'true')\n\t\t\txhr.setRequestHeader('X-PJAX-Container', context.selector)\n\n\t\t\tif (!fire('pjax:beforeSend', [xhr, settings]))\n\t\t\t\treturn false\n\n\t\t\tif (settings.timeout > 0) {\n\t\t\t\ttimeoutTimer = setTimeout(function () {\n\t\t\t\t\tif (fire('pjax:timeout', [xhr, options]))\n\t\t\t\t\t\txhr.abort('timeout')\n\t\t\t\t}, settings.timeout)\n\n\t\t\t\t// Clear timeout setting so jquerys internal timeout isn't invoked\n\t\t\t\tsettings.timeout = 0\n\t\t\t}\n\n\t\t\toptions.requestUrl = parseURL(settings.url).href\n\t\t}\n\n\t\toptions.complete = function (xhr, textStatus) {\n\t\t\tif (timeoutTimer)\n\t\t\t\tclearTimeout(timeoutTimer)\n\n\t\t\tfire('pjax:complete', [xhr, textStatus, options])\n\n\t\t\tfire('pjax:end', [xhr, options])\n\t\t}\n\n\t\toptions.error = function (xhr, textStatus, errorThrown) {\n\t\t\tvar container = extractContainer(\"\", xhr, options)\n\t\t\t// Check redirect status code\n\t\t\tvar redirect = (xhr.status >= 301 && xhr.status <= 303)\n\t\t\t// Do not fire pjax::error in case of redirect\n\t\t\tvar allowed = redirect || fire('pjax:error', [xhr, textStatus, errorThrown, options])\n\t\t\tif (redirect || (options.type == 'GET' && textStatus !== 'abort' && allowed)) {\n\t\t\t\tlocationReplace(container.url)\n\t\t\t}\n\t\t}\n\n\t\toptions.success = function (data, status, xhr) {\n\t\t\t// If $.pjax.defaults.version is a function, invoke it first.\n\t\t\t// Otherwise it can be a static string.\n\t\t\tvar currentVersion = (typeof $.pjax.defaults.version === 'function') ?\n\t\t\t\t$.pjax.defaults.version() :\n\t\t\t\t$.pjax.defaults.version\n\n\t\t\tvar latestVersion = xhr.getResponseHeader('X-PJAX-Version')\n\n\t\t\tvar container = extractContainer(data, xhr, options)\n\n\t\t\t// If there is a layout version mismatch, hard load the new url\n\t\t\tif (currentVersion && latestVersion && currentVersion !== latestVersion) {\n\t\t\t\tlocationReplace(container.url)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If the new response is missing a body, hard load the page\n\t\t\tif (!container.contents) {\n\t\t\t\tlocationReplace(container.url)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpjax.state = {\n\t\t\t\tid: options.id || uniqueId(),\n\t\t\t\turl: container.url,\n\t\t\t\ttitle: container.title,\n\t\t\t\tcontainer: context.selector,\n\t\t\t\tfragment: options.fragment,\n\t\t\t\ttimeout: options.timeout\n\t\t\t}\n\n\t\t\tif (options.push || options.replace) {\n\t\t\t\twindow.history.replaceState(pjax.state, container.title, container.url)\n\t\t\t}\n\n\t\t\t// Clear out any focused controls before inserting new page contents.\n\t\t\tdocument.activeElement.blur()\n\n\t\t\tif (container.title) document.title = container.title\n\t\t\tcontext.html(container.contents)\n\n\t\t\t// FF bug: Won't autofocus fields that are inserted via JS.\n\t\t\t// This behavior is incorrect. So if theres no current focus, autofocus\n\t\t\t// the last field.\n\t\t\t//\n\t\t\t// http://www.w3.org/html/wg/drafts/html/master/forms.html\n\t\t\tvar autofocusEl = context.find('input[autofocus], textarea[autofocus]').last()[0]\n\t\t\tif (autofocusEl && document.activeElement !== autofocusEl) {\n\t\t\t\tautofocusEl.focus();\n\t\t\t}\n\n\t\t\texecuteScriptTags(container.scripts)\n\n\t\t\t// Scroll to top by default\n\t\t\tif (typeof options.scrollTo === 'number')\n\t\t\t\t$(window).scrollTop(options.scrollTo)\n\n\t\t\t// If the URL has a hash in it, make sure the browser\n\t\t\t// knows to navigate to the hash.\n\t\t\tif (hash !== '') {\n\t\t\t\t// Avoid using simple hash set here. Will add another history\n\t\t\t\t// entry. Replace the url with replaceState and scroll to target\n\t\t\t\t// by hand.\n\t\t\t\t//\n\t\t\t\t//   window.location.hash = hash\n\t\t\t\tvar url = parseURL(container.url)\n\t\t\t\turl.hash = hash\n\n\t\t\t\tpjax.state.url = url.href\n\t\t\t\twindow.history.replaceState(pjax.state, container.title, url.href)\n\n\t\t\t\tvar target = $(url.hash)\n\t\t\t\tif (target.length) $(window).scrollTop(target.offset().top)\n\t\t\t}\n\n\t\t\tfire('pjax:success', [data, status, xhr, options])\n\t\t}\n\n\n\t\t// Initialize pjax.state for the initial page load. Assume we're\n\t\t// using the container and options of the link we're loading for the\n\t\t// back button to the initial page. This ensures good back button\n\t\t// behavior.\n\t\tif (!pjax.state) {\n\t\t\tpjax.state = {\n\t\t\t\tid: uniqueId(),\n\t\t\t\turl: window.location.href,\n\t\t\t\ttitle: document.title,\n\t\t\t\tcontainer: context.selector,\n\t\t\t\tfragment: options.fragment,\n\t\t\t\ttimeout: options.timeout\n\t\t\t}\n\t\t\twindow.history.replaceState(pjax.state, document.title)\n\t\t}\n\n\t\t// Cancel the current request if we're already pjaxing\n\t\tvar xhr = pjax.xhr\n\t\tif (xhr && xhr.readyState < 4) {\n\t\t\txhr.onreadystatechange = $.noop\n\t\t\txhr.abort()\n\t\t}\n\n\t\t// Strip _pjax parameter from URL, if exists.\n\t\toptions.url = stripPjaxParam(options.url);\n\n\t\tpjax.options = options\n\t\tvar xhr = pjax.xhr = $.ajax(options)\n\n\t\tif (xhr.readyState > 0) {\n\t\t\tif (options.push && !options.replace) {\n\t\t\t\t// Cache current container element before replacing it\n\t\t\t\tcachePush(pjax.state.id, context.clone().contents())\n\n\t\t\t\twindow.history.pushState(null, \"\", stripPjaxParam(options.requestUrl))\n\t\t\t}\n\n\t\t\tfire('pjax:start', [xhr, options])\n\t\t\tfire('pjax:send', [xhr, options])\n\t\t}\n\n\t\treturn pjax.xhr\n\t}\n\n// Public: Reload current page with pjax.\n//\n// Returns whatever $.pjax returns.\n\tfunction pjaxReload(container, options) {\n\t\tvar defaults = {\n\t\t\turl: window.location.href,\n\t\t\tpush: false,\n\t\t\treplace: true,\n\t\t\tscrollTo: false\n\t\t}\n\n\t\treturn pjax($.extend(defaults, optionsFor(container, options)))\n\t}\n\n// Internal: Hard replace current state with url.\n//\n// Work for around WebKit\n//   https://bugs.webkit.org/show_bug.cgi?id=93506\n//\n// Returns nothing.\n\tfunction locationReplace(url) {\n\t\twindow.history.replaceState(null, \"\", \"#\")\n\t\twindow.location.replace(url)\n\t}\n\n\n\tvar initialPop = true\n\tvar initialURL = window.location.href\n\tvar initialState = window.history.state\n\n// Initialize $.pjax.state if possible\n// Happens when reloading a page and coming forward from a different\n// session history.\n\tif (initialState && initialState.container) {\n\t\tpjax.state = initialState\n\t}\n\n// Non-webkit browsers don't fire an initial popstate event\n\tif ('state' in window.history) {\n\t\tinitialPop = false\n\t}\n\n// popstate handler takes care of the back and forward buttons\n//\n// You probably shouldn't use pjax on pages with other pushState\n// stuff yet.\n\tfunction onPjaxPopstate(event) {\n\t\tvar state = event.state\n\n\t\tif (state && state.container) {\n\t\t\t// When coming forward from a separate history session, will get an\n\t\t\t// initial pop with a state we are already at. Skip reloading the current\n\t\t\t// page.\n\t\t\tif (initialPop && initialURL == state.url) return\n\n\t\t\t// If popping back to the same state, just skip.\n\t\t\t// Could be clicking back from hashchange rather than a pushState.\n\t\t\tif (pjax.state.id === state.id) return\n\n\t\t\tvar container = $(state.container)\n\t\t\tif (container.length) {\n\t\t\t\tvar direction, contents = cacheMapping[state.id]\n\n\t\t\t\tif (pjax.state) {\n\t\t\t\t\t// Since state ids always increase, we can deduce the history\n\t\t\t\t\t// direction from the previous state.\n\t\t\t\t\tdirection = pjax.state.id < state.id ? 'forward' : 'back'\n\n\t\t\t\t\t// Cache current container before replacement and inform the\n\t\t\t\t\t// cache which direction the history shifted.\n\t\t\t\t\tcachePop(direction, pjax.state.id, container.clone().contents())\n\t\t\t\t}\n\n\t\t\t\tvar popstateEvent = $.Event('pjax:popstate', {\n\t\t\t\t\tstate: state,\n\t\t\t\t\tdirection: direction\n\t\t\t\t})\n\t\t\t\tcontainer.trigger(popstateEvent)\n\n\t\t\t\tvar options = {\n\t\t\t\t\tid: state.id,\n\t\t\t\t\turl: state.url,\n\t\t\t\t\tcontainer: container,\n\t\t\t\t\tpush: false,\n\t\t\t\t\tfragment: state.fragment,\n\t\t\t\t\ttimeout: state.timeout,\n\t\t\t\t\tscrollTo: false\n\t\t\t\t}\n\n\t\t\t\tif (contents) {\n\t\t\t\t\tcontainer.trigger('pjax:start', [null, options])\n\n\t\t\t\t\tif (state.title) document.title = state.title\n\t\t\t\t\tcontainer.html(contents)\n\t\t\t\t\tpjax.state = state\n\n\t\t\t\t\tcontainer.trigger('pjax:end', [null, options])\n\t\t\t\t} else {\n\t\t\t\t\tpjax(options)\n\t\t\t\t}\n\n\t\t\t\t// Force reflow/relayout before the browser tries to restore the\n\t\t\t\t// scroll position.\n\t\t\t\tcontainer[0].offsetHeight\n\t\t\t} else {\n\t\t\t\tlocationReplace(location.href)\n\t\t\t}\n\t\t}\n\t\tinitialPop = false\n\t}\n\n// Fallback version of main pjax function for browsers that don't\n// support pushState.\n//\n// Returns nothing since it retriggers a hard form submission.\n\tfunction fallbackPjax(options) {\n\t\tvar url = $.isFunction(options.url) ? options.url() : options.url,\n\t\t\tmethod = options.type ? options.type.toUpperCase() : 'GET'\n\n\t\tvar form = $('<form>', {\n\t\t\tmethod: method === 'GET' ? 'GET' : 'POST',\n\t\t\taction: url,\n\t\t\tstyle: 'display:none'\n\t\t})\n\n\t\tif (method !== 'GET' && method !== 'POST') {\n\t\t\tform.append($('<input>', {\n\t\t\t\ttype: 'hidden',\n\t\t\t\tname: '_method',\n\t\t\t\tvalue: method.toLowerCase()\n\t\t\t}))\n\t\t}\n\n\t\tvar data = options.data\n\t\tif (typeof data === 'string') {\n\t\t\t$.each(data.split('&'), function (index, value) {\n\t\t\t\tvar pair = value.split('=')\n\t\t\t\tform.append($('<input>', {type: 'hidden', name: pair[0], value: pair[1]}))\n\t\t\t})\n\t\t} else if (typeof data === 'object') {\n\t\t\tfor (key in data)\n\t\t\t\tform.append($('<input>', {type: 'hidden', name: key, value: data[key]}))\n\t\t}\n\n\t\t$(document.body).append(form)\n\t\tform.submit()\n\t}\n\n// Internal: Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be\n// unique across page loads.\n//\n// Returns Number.\n\tfunction uniqueId() {\n\t\treturn (new Date).getTime()\n\t}\n\n// Internal: Strips _pjax param from url\n//\n// url - String\n//\n// Returns String.\n\tfunction stripPjaxParam(url) {\n\t\treturn url\n\t\t\t.replace(/\\?_pjax=[^&]+&?/, '?')\n\t\t\t.replace(/_pjax=[^&]+&?/, '')\n\t\t\t.replace(/[\\?&]$/, '')\n\t}\n\n// Internal: Parse URL components and returns a Locationish object.\n//\n// url - String URL\n//\n// Returns HTMLAnchorElement that acts like Location.\n\tfunction parseURL(url) {\n\t\tvar a = document.createElement('a')\n\t\ta.href = url\n\t\treturn a\n\t}\n\n// Internal: Build options Object for arguments.\n//\n// For convenience the first parameter can be either the container or\n// the options object.\n//\n// Examples\n//\n//   optionsFor('#container')\n//   // => {container: '#container'}\n//\n//   optionsFor('#container', {push: true})\n//   // => {container: '#container', push: true}\n//\n//   optionsFor({container: '#container', push: true})\n//   // => {container: '#container', push: true}\n//\n// Returns options Object.\n\tfunction optionsFor(container, options) {\n\t\t// Both container and options\n\t\tif (container && options)\n\t\t\toptions.container = container\n\n\t\t// First argument is options Object\n\t\telse if ($.isPlainObject(container))\n\t\t\toptions = container\n\n\t\t// Only container\n\t\telse\n\t\t\toptions = {container: container}\n\n\t\t// Find and validate container\n\t\tif (options.container)\n\t\t\toptions.container = findContainerFor(options.container)\n\n\t\treturn options\n\t}\n\n// Internal: Find container element for a variety of inputs.\n//\n// Because we can't persist elements using the history API, we must be\n// able to find a String selector that will consistently find the Element.\n//\n// container - A selector String, jQuery object, or DOM Element.\n//\n// Returns a jQuery object whose context is `document` and has a selector.\n\tfunction findContainerFor(container) {\n\t\tcontainer = $(container)\n\n\t\tif (!container.length) {\n\t\t\tthrow \"no pjax container for \" + container.selector\n\t\t} else if (container.selector !== '' && container.context === document) {\n\t\t\treturn container\n\t\t} else if (container.attr('id')) {\n\t\t\treturn $('#' + container.attr('id'))\n\t\t} else {\n\t\t\tthrow \"cant get selector for pjax container!\"\n\t\t}\n\t}\n\n// Internal: Filter and find all elements matching the selector.\n//\n// Where $.fn.find only matches descendants, findAll will test all the\n// top level elements in the jQuery object as well.\n//\n// elems    - jQuery object of Elements\n// selector - String selector to match\n//\n// Returns a jQuery object.\n\tfunction findAll(elems, selector) {\n\t\treturn elems.filter(selector).add(elems.find(selector));\n\t}\n\n\tfunction parseHTML(html) {\n\t\treturn $.parseHTML(html, document, true)\n\t}\n\n// Internal: Extracts container and metadata from response.\n//\n// 1. Extracts X-PJAX-URL header if set\n// 2. Extracts inline <title> tags\n// 3. Builds response Element and extracts fragment if set\n//\n// data    - String response data\n// xhr     - XHR response\n// options - pjax options Object\n//\n// Returns an Object with url, title, and contents keys.\n\tfunction extractContainer(data, xhr, options) {\n\t\tvar obj = {}\n\n\t\t// Prefer X-PJAX-URL header if it was set, otherwise fallback to\n\t\t// using the original requested url.\n\t\tobj.url = stripPjaxParam(xhr.getResponseHeader('X-PJAX-URL') || options.requestUrl)\n\n\t\t// Attempt to parse response html into elements\n\t\tif (/<html/i.test(data)) {\n\t\t\tvar $head = $(parseHTML(data.match(/<head[^>]*>([\\s\\S.]*)<\\/head>/i)[0]))\n\t\t\tvar $body = $(parseHTML(data.match(/<body[^>]*>([\\s\\S.]*)<\\/body>/i)[0]))\n\t\t} else {\n\t\t\tvar $head = $body = $(parseHTML(data))\n\t\t}\n\n\t\t// If response data is empty, return fast\n\t\tif ($body.length === 0)\n\t\t\treturn obj\n\n\t\t// If there's a <title> tag in the header, use it as\n\t\t// the page's title.\n\t\tobj.title = findAll($head, 'title').last().text()\n\n\t\tif (options.fragment) {\n\t\t\t// If they specified a fragment, look for it in the response\n\t\t\t// and pull it out.\n\t\t\tif (options.fragment === 'body') {\n\t\t\t\tvar $fragment = $body\n\t\t\t} else {\n\t\t\t\tvar $fragment = findAll($body, options.fragment).first()\n\t\t\t}\n\n\t\t\tif ($fragment.length) {\n\t\t\t\tobj.contents = $fragment.contents()\n\n\t\t\t\t// If there's no title, look for data-title and title attributes\n\t\t\t\t// on the fragment\n\t\t\t\tif (!obj.title)\n\t\t\t\t\tobj.title = $fragment.attr('title') || $fragment.data('title')\n\t\t\t}\n\n\t\t} else if (!/<html/i.test(data)) {\n\t\t\tobj.contents = $body\n\t\t}\n\n\t\t// Clean up any <title> tags\n\t\tif (obj.contents) {\n\t\t\t// Remove any parent title elements\n\t\t\tobj.contents = obj.contents.not(function () {\n\t\t\t\treturn $(this).is('title')\n\t\t\t})\n\n\t\t\t// Then scrub any titles from their descendants\n\t\t\tobj.contents.find('title').remove()\n\n\t\t\t// Gather all script[src] elements\n\t\t\t// modifier by mole: This handle cause the script which not src node handle error, if the script depend some script.\n\t\t\t// obj.scripts = findAll(obj.contents, 'script[src]').remove() \n\t\t\t// obj.contents = obj.contents.not(obj.scripts)\n\t\t}\n\n\t\t// Trim any whitespace off the title\n\t\tif (obj.title) obj.title = $.trim(obj.title)\n\n\t\treturn obj\n\t}\n\n// Load an execute scripts using standard script request.\n//\n// Avoids jQuery's traditional $.getScript which does a XHR request and\n// globalEval.\n//\n// scripts - jQuery object of script Elements\n//\n// Returns nothing.\n\tfunction executeScriptTags(scripts) {\n\t\tif (!scripts) return\n\n\t\tvar existingScripts = $('script[src]')\n\n\t\tscripts.each(function () {\n\t\t\tvar src = this.src\n\t\t\tvar matchedScripts = existingScripts.filter(function () {\n\t\t\t\treturn this.src === src\n\t\t\t})\n\t\t\tif (matchedScripts.length) return\n\n\t\t\tvar script = document.createElement('script')\n\t\t\tscript.type = $(this).attr('type') || 'text/javascript';\n\t\t\tscript.src = $(this).attr('src')\n\t\t\tdocument.head.appendChild(script)\n\t\t})\n\t}\n\n// Internal: History DOM caching class.\n\tvar cacheMapping = {}\n\tvar cacheForwardStack = []\n\tvar cacheBackStack = []\n\n// Push previous state id and container contents into the history\n// cache. Should be called in conjunction with `pushState` to save the\n// previous container contents.\n//\n// id    - State ID Number\n// value - DOM Element to cache\n//\n// Returns nothing.\n\tfunction cachePush(id, value) {\n\t\tcacheMapping[id] = value\n\t\tcacheBackStack.push(id)\n\n\t\t// Remove all entires in forward history stack after pushing\n\t\t// a new page.\n\t\twhile (cacheForwardStack.length)\n\t\t\tdelete cacheMapping[cacheForwardStack.shift()]\n\n\t\t// Trim back history stack to max cache length.\n\t\twhile (cacheBackStack.length > pjax.defaults.maxCacheLength)\n\t\t\tdelete cacheMapping[cacheBackStack.shift()]\n\t}\n\n// Shifts cache from directional history cache. Should be\n// called on `popstate` with the previous state id and container\n// contents.\n//\n// direction - \"forward\" or \"back\" String\n// id        - State ID Number\n// value     - DOM Element to cache\n//\n// Returns nothing.\n\tfunction cachePop(direction, id, value) {\n\t\tvar pushStack, popStack\n\t\tcacheMapping[id] = value\n\n\t\tif (direction === 'forward') {\n\t\t\tpushStack = cacheBackStack\n\t\t\tpopStack = cacheForwardStack\n\t\t} else {\n\t\t\tpushStack = cacheForwardStack\n\t\t\tpopStack = cacheBackStack\n\t\t}\n\n\t\tpushStack.push(id)\n\t\tif (id = popStack.pop())\n\t\t\tdelete cacheMapping[id]\n\t}\n\n// Public: Find version identifier for the initial page load.\n//\n// Returns String version or undefined.\n\tfunction findVersion() {\n\t\treturn $('meta').filter(function () {\n\t\t\tvar name = $(this).attr('http-equiv')\n\t\t\treturn name && name.toUpperCase() === 'X-PJAX-VERSION'\n\t\t}).attr('content')\n\t}\n\n// Install pjax functions on $.pjax to enable pushState behavior.\n//\n// Does nothing if already enabled.\n//\n// Examples\n//\n//     $.pjax.enable()\n//\n// Returns nothing.\n\tfunction enable() {\n\t\t$.fn.pjax = fnPjax\n\t\t$.pjax = pjax\n\t\t$.pjax.enable = $.noop\n\t\t$.pjax.disable = disable\n\t\t$.pjax.click = handleClick\n\t\t$.pjax.submit = handleSubmit\n\t\t$.pjax.reload = pjaxReload\n\t\t$.pjax.defaults = {\n\t\t\ttimeout: 650,\n\t\t\tpush: true,\n\t\t\treplace: false,\n\t\t\ttype: 'GET',\n\t\t\tdataType: 'html',\n\t\t\tscrollTo: 0,\n\t\t\tmaxCacheLength: 20,\n\t\t\tversion: findVersion\n\t\t}\n\t\t$(window).on('popstate.pjax', onPjaxPopstate)\n\t}\n\n// Disable pushState behavior.\n//\n// This is the case when a browser doesn't support pushState. It is\n// sometimes useful to disable pushState for debugging on a modern\n// browser.\n//\n// Examples\n//\n//     $.pjax.disable()\n//\n// Returns nothing.\n\tfunction disable() {\n\t\t$.fn.pjax = function () {\n\t\t\treturn this\n\t\t}\n\t\t$.pjax = fallbackPjax\n\t\t$.pjax.enable = enable\n\t\t$.pjax.disable = $.noop\n\t\t$.pjax.click = $.noop\n\t\t$.pjax.submit = $.noop\n\t\t$.pjax.reload = function () {\n\t\t\twindow.location.reload()\n\t\t}\n\n\t\t$(window).off('popstate.pjax', onPjaxPopstate)\n\t}\n\n\n// Add the state property to jQuery's event object so we can use it in\n// $(window).bind('popstate')\n\tif ($.inArray('state', $.event.props) < 0)\n\t\t$.event.props.push('state')\n\n// Is pjax supported by this browser?\n\t$.support.pjax =\n\t\twindow.history && window.history.pushState && window.history.replaceState &&\n\t\t\t// pushState isn't reliable on iOS until 5.\n\t\t\t!navigator.userAgent.match(/((iPod|iPhone|iPad).+\\bOS\\s+[1-4]|WebApps\\/.+CFNetwork)/)\n\n\t$.support.pjax ? enable() : disable()\n\n})(jQuery);\n"],"sourceRoot":"/source/"}